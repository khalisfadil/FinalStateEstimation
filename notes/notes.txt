Mittwoch, 2. Juli 2025 16:05
    - does keypoints and const_frame is different?
    - grid sampling provide initialized frame and keypoints.
    - initializeFrame has sub_sample_frame >> output >> downsampling of given input frame.
    - grid_sampling, copy the input frame and do sub_sample_frame, move(transform) downsampled frame into keypoints.
    - NOTE: grid_sampling can be optimized. redundancies operations.
    - initializeFrame has undo the motion distortion. it does shuffling of the points inside its frame.
    - keypoints is a frame that has undergoes second downsampling operations.
    - keypoints has undergoes motion undistortion. timestamp change? lookslike it retain its original timestamp
    - TODO: dataalingment, make sure the IMU data is inside the lidar frame.
    - I have calculated that every lidar frame, we have maximum of 5 IMU measurement.
    - stop at step 34 in icp.
--------------------------------------------------------------------------------------------------------------------------
Donnerstag, 3. Juli 2025 08:56
    - start from step 37 I remove runtime error to ease the code.
    - stopped at step 45
--------------------------------------------------------------------------------------------------------------------------
Montag, 7. Juli 2025 12:06
    - finished checking function icp
    - added glog in icp
    - finished recheck all function in lidarinertialodometry
--------------------------------------------------------------------------------------------------------------------------
Montag, 14. Juli 2025 13:58
    - I have add subsampling outlier removal inside grid sampling. so that it will remove outlier.
    - in the "register frame" the lidar point undergoes initialize frame without subsampling removal. then go grid sampling withoutlier removal.
    - we can change this vice versa if we think its not working.
    - build all slamming is working on target 7.
    - TODO: complete the slamming pipeline
    - for map, I have take a look many times and it is not possible to apply tbb parallel on it. until now we stay with tsl-robin.
--------------------------------------------------------------------------------------------------------------------------
Dienstag, 15. Juli 2025 11:08
    - I check the main.cpp from steam_icp
    - > options.odometry_options = SteamLioOdometry --line195
    - ROS2_PARAM_CLAUSE is initialize as my json file
    - auto &steam_icp_options = dynamic_cast<SteamLioOdometry::Options &>(odometry_options);
    - tsl::robin_map supports concurrent reads but not writes without synchronization
    - I have update map.hpp to potential a better and safer version.
--------------------------------------------------------------------------------------------------------------------------
Mittwoch, 16. Juli 2025 09:41
    - add trajectory.hpp with brief comment
    - going back to Transformation understanding
    - Tworld,new​=Tworld,old​ * Trelative, where Trelative define from LLA2NED and RPY of the compass.
    - LLA2NED, the NED is relative translation
    - I have been adviced to remove the global control on each of my tbb function especially in finalstateestimation. will do tomorrow.
--------------------------------------------------------------------------------------------------------------------------
Montag, 21. Juli 2025 10:04
    - I have double check the map.hpp until today there is not bug that I can found. expected map.hpp to works okay.
    - "Hey, if anyone ever asks for the string "SLAM_LIDAR_INERTIAL_ODOM", you should use the constructor for the lidarinertialodom class to create the object they want."
    - Phase 1: The Setup (Automatic Program Startup)
        - This phase prepares the system.
        - Registration: Inside the lidarinertialodom.hpp file, the SLAM_REGISTER_ODOMETRY macro creates a special static helper object.
        - Auto-Run: Because this object is static, its constructor (OdometryRegister()) runs automatically when the program launches.
        - Populate the "Menu": This constructor adds an entry to a central, hidden static map inside the Odometry class. The entry consists of:
        - The Key: The string "SLAM_LIDAR_INERTIAL_ODOM".
        - The Value: A "recipe" (a C++ lambda) for how to create a lidarinertialodom object.
    - At the end of this phase, the system knows that "SLAM_LIDAR_INERTIAL_ODOM" exists, but no lidarinertialodom object has actually been created yet.
    - Phase 2: The Action (When Get is Called)
        - This phase happens when your SLAMPipeline code runs.
        - The Request: Your code calls Odometry::Get("SLAM_LIDAR_INERTIAL_ODOM", json_path).
        - Lookup: The Get function looks up the string "SLAM_LIDAR_INERTIAL_ODOM" in the central map and finds the "recipe" that was registered in Phase 1.
        - Execution: The Get function executes the recipe, handing it the json_path string.
        - Creation: The recipe's only instruction is to call std::make_shared<lidarinertialodom>(json_path). This is the moment the lidarinertialodom object is finally constructed. Its constructor uses the json_path to load all its settings from the file.
        - Return: A pointer to the new, fully-configured lidarinertialodom object is returned to the SLAMPipeline.
--------------------------------------------------------------------------------------------------------------------------
